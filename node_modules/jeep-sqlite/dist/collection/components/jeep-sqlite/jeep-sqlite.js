import { Database } from "../../utils/database";
import localForage from "localforage";
import { UtilsJSON } from "../../utils/utils-json";
import { UtilsStore } from "../../utils/utils-store";
import * as JSZip from "jszip";
import { fileOpen, fileSave, supported } from "browser-fs-access";
export class JeepSqlite {
    constructor() {
        this.isStore = false;
        this._dbDict = {};
        this.databaseList = {};
        this._versionUpgrades = {};
        this._overwrite = true;
        this.autoSave = false;
        this.typeOrm = false;
        this.wasmPath = undefined;
        this.pickText = undefined;
        this.saveText = undefined;
        this.buttonOptions = undefined;
        this.innerAutoSave = undefined;
        this.innerTypeOrm = undefined;
        this.innerWasmPath = undefined;
        this.innerPickText = undefined;
        this.innerSaveText = undefined;
        this.innerButtonOptions = undefined;
    }
    //*****************************
    //* Watch on Property Changes *
    //*****************************
    parseAutoSave(newValue) {
        this.innerAutoSave = newValue;
    }
    parseTypeOrm(newValue) {
        this.innerTypeOrm = newValue;
    }
    parseWasmPath(newValue) {
        this.innerWasmPath = newValue;
    }
    parsePickText(newValue) {
        this.innerPickText = newValue;
    }
    parseSaveText(newValue) {
        this.innerSaveText = newValue;
    }
    parseButtonOptions(newValue) {
        this.innerButtonOptions = JSON.parse(newValue);
        const keys = Object.keys(this.innerButtonOptions);
        for (const key of keys) {
            switch (key) {
                case "top": {
                    this.el.style.setProperty('--jeep-sqlite-top', this.innerButtonOptions[key]);
                    break;
                }
                case "right": {
                    this.el.style.setProperty('--jeep-sqlite-right', this.innerButtonOptions[key]);
                    break;
                }
                case "fontSize": {
                    this.el.style.setProperty('--jeep-sqlite-font-size', this.innerButtonOptions[key]);
                    break;
                }
                case "padding": {
                    this.el.style.setProperty('--jeep-sqlite-padding', this.innerButtonOptions[key]);
                    break;
                }
                case "backgroundColor": {
                    this.el.style.setProperty('--jeep-sqlite-background-color', this.innerButtonOptions[key]);
                    break;
                }
                case "color": {
                    this.el.style.setProperty('--jeep-sqlite-color', this.innerButtonOptions[key]);
                    break;
                }
            }
        }
    }
    //**********************
    //* Method Definitions *
    //**********************
    async echo(options) {
        return options;
    }
    async createConnection(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const version = options.version ? options.version : 1;
        const readonly = options.readonly ? options.readonly : false;
        try {
            await this._createConnection(dbName, version, readonly);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isConnection(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        const ret = await this._isConnection(dbName, readonly);
        return Promise.resolve(ret);
    }
    async closeConnection(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        try {
            await this._closeConnection(dbName, readonly);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async open(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        try {
            await this._open(dbName, readonly);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async close(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        try {
            await this._close(dbName, readonly);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getVersion(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        try {
            const res = await this._getVersion(dbName, readonly);
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async beginTransaction(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        if (readonly) {
            return Promise.reject(`BeginTransaction: not allowed in read-only mode`);
        }
        try {
            const changes = await this._beginTransaction(dbName);
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async commitTransaction(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        if (readonly) {
            return Promise.reject(`CommitTransaction: not allowed in read-only mode`);
        }
        try {
            const changes = await this._commitTransaction(dbName);
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async rollbackTransaction(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        if (readonly) {
            return Promise.reject(`BeginTransaction: not allowed in read-only mode`);
        }
        try {
            const changes = await this._rollbackTransaction(dbName);
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isTransactionActive(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        if (readonly) {
            return Promise.reject(`isTransactionActive: not allowed in read-only mode`);
        }
        try {
            const res = await this._isTransactionActive(dbName);
            return Promise.resolve(res);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async execute(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('statements') || options.statements.length === 0) {
            return Promise.reject('Must provide raw SQL statements');
        }
        const dbName = options.database;
        const statements = options.statements;
        let transaction = true;
        const readonly = options.readonly ? options.readonly : false;
        if (keys.includes('transaction'))
            transaction = options.transaction;
        try {
            const changes = await this._execute(dbName, statements, transaction, readonly);
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async executeSet(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('set') || options.set.length === 0) {
            return Promise.reject('Must provide a non-empty set of SQL statements');
        }
        const dbName = options.database;
        const setOfStatements = options.set;
        let transaction = true;
        if (keys.includes('transaction'))
            transaction = options.transaction;
        const readonly = options.readonly ? options.readonly : false;
        const returnMode = options.returnMode ? options.returnMode : 'no';
        try {
            const changes = await this._executeSet(dbName, setOfStatements, transaction, readonly, returnMode);
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async run(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('statement') || options.statement.length === 0) {
            return Promise.reject('Must provide a run statement');
        }
        const dbName = options.database;
        const statement = options.statement;
        let values = [];
        if (keys.includes('values')) {
            values = options.values.length > 0 ? options.values : [];
        }
        let transaction = true;
        if (keys.includes('transaction'))
            transaction = options.transaction;
        const readonly = options.readonly ? options.readonly : false;
        const returnMode = options.returnMode ? options.returnMode : 'no';
        try {
            const retChanges = await this._run(dbName, statement, values, transaction, readonly, returnMode);
            return Promise.resolve(retChanges);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async query(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('statement') || options.statement.length === 0) {
            return Promise.reject('Must provide a query statement');
        }
        let values = [];
        if (keys.includes('values')) {
            values = options.values.length > 0 ? options.values : [];
        }
        const dbName = options.database;
        const statement = options.statement;
        const readonly = options.readonly ? options.readonly : false;
        try {
            const retValues = await this._query(dbName, statement, values, readonly);
            return Promise.resolve(retValues);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getTableList(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        try {
            const retValues = await this._getTableList(dbName, readonly);
            return Promise.resolve(retValues);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isDBExists(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        try {
            const ret = await this._isDBExists(dbName, readonly);
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isDBOpen(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        try {
            const ret = await this._isDBOpen(dbName, readonly);
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async deleteDatabase(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        try {
            return await this._deleteDatabase(dbName, readonly);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isStoreOpen() {
        return Promise.resolve(this.isStore);
    }
    async copyFromAssets(options) {
        let overwrite;
        if (options != null) {
            const keys = Object.keys(options);
            overwrite = keys.includes('overwrite') ? options.overwrite : true;
        }
        else {
            overwrite = true;
        }
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        try {
            await this._copyFromAssets(overwrite);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isTableExists(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        if (!keys.includes('table')) {
            return Promise.reject('Must provide a table name');
        }
        const tableName = options.table;
        const readonly = options.readonly ? options.readonly : false;
        try {
            const ret = await this._isTableExists(dbName, tableName, readonly);
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async createSyncTable(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        try {
            const ret = await this._createSyncTable(dbName, readonly);
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getSyncDate(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        try {
            const ret = await this._getSyncDate(dbName, readonly);
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async setSyncDate(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('syncdate')) {
            return Promise.reject('Must provide a synchronization date');
        }
        const dbName = options.database;
        const syncDate = options.syncdate;
        const readonly = options.readonly ? options.readonly : false;
        try {
            await this._setSyncDate(dbName, syncDate, readonly);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async isJsonValid(options) {
        const keys = Object.keys(options);
        if (!keys.includes('jsonstring')) {
            return Promise.reject('Must provide a json object');
        }
        const jsonStrObj = options.jsonstring;
        try {
            const ret = await this._isJsonValid(jsonStrObj);
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async importFromJson(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('jsonstring')) {
            return Promise.reject('Must provide a json object');
        }
        const jsonStrObj = options.jsonstring;
        try {
            const ret = await this._importFromJson(jsonStrObj);
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async exportToJson(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('jsonexportmode')) {
            return Promise.reject('Must provide a json export mode');
        }
        const dbName = options.database;
        const exportMode = options.jsonexportmode;
        const readonly = options.readonly ? options.readonly : false;
        try {
            const ret = await this._exportToJson(dbName, exportMode, readonly);
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async deleteExportedRows(options) {
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        try {
            await this._deleteExportedRows(dbName, readonly);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async addUpgradeStatement(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('upgrade')) {
            return Promise.reject('Must provide an upgrade capSQLiteVersionUpgrade Object');
        }
        const dbName = options.database;
        const upgrades = options.upgrade;
        for (const upgrade of upgrades) {
            const versionUpgradeKeys = Object.keys(upgrade);
            if (!versionUpgradeKeys.includes('toVersion') ||
                !versionUpgradeKeys.includes('statements')) {
                return Promise.reject('Must provide an upgrade capSQLiteVersionUpgrade Object');
            }
            if (typeof upgrade.toVersion != 'number') {
                return Promise.reject('upgrade.toVersion must be a number');
            }
            if (this._versionUpgrades[dbName]) {
                this._versionUpgrades[dbName][upgrade.toVersion] = upgrade;
            }
            else {
                const upgVDict = {};
                upgVDict[upgrade.toVersion] = upgrade;
                this._versionUpgrades[dbName] = upgVDict;
            }
        }
        return Promise.resolve();
    }
    async isDatabase(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        try {
            const ret = await this._isDatabase(dbName);
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getDatabaseList() {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        try {
            const ret = await this._getDatabaseList();
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async checkConnectionsConsistency(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('dbNames')) {
            return Promise.reject(`Must provide a list of connection's name`);
        }
        const dbNames = options.dbNames;
        if (!keys.includes('openModes')) {
            return Promise.reject(`Must provide a list of connection's open mode`);
        }
        const openModes = options.openModes;
        try {
            const ret = await this._checkConnectionsConsistency(dbNames, openModes);
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async saveToStore(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const readonly = options.readonly ? options.readonly : false;
        try {
            await this._saveToStore(dbName, readonly);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async saveToLocalDisk(options) {
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        try {
            await this._saveToLocalDisk(dbName);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getFromLocalDiskToStore(options) {
        const overwrite = options.overwrite ? options.overwrite : true;
        if (supported) {
            console.log('Using the File System Access API.');
        }
        else {
            console.log('Using the fallback implementation.');
        }
        try {
            await this._getFromLocalDiskToStore(overwrite);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async getFromHTTPRequest(options) {
        if (!this.isStore) {
            return Promise.reject(`>>> jeep-sqlite StoreName: ${this.storeName} is not opened`);
        }
        let keys = Object.keys(options);
        if (!keys.includes('url')) {
            return Promise.reject('Must provide an url');
        }
        const url = options.url;
        const overwrite = options.overwrite ? options.overwrite : true;
        try {
            await this._getFromHTTPRequest(url, overwrite);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    //*******************************
    //* Component Lifecycle Methods *
    //*******************************
    connectedCallback() {
        this.parseAutoSave(this.autoSave !== undefined ? this.autoSave : false);
        this.parseTypeOrm(this.typeOrm !== undefined ? this.typeOrm : false);
        this.parseWasmPath(this.wasmPath !== undefined ? this.wasmPath : '/assets');
        this.parseSaveText(this.saveText !== undefined ? this.saveText : 'Save');
        this.parsePickText(this.pickText !== undefined ? this.pickText : 'Pick a database');
        if (this.buttonOptions !== undefined) {
            this.parseButtonOptions(this.buttonOptions);
        }
        this.openStore("jeepSqliteStore", "databases").then((mStore) => {
            this.isStore = mStore;
        });
    }
    componentWillLoad() {
    }
    async componentDidLoad() {
        this._element = this.el.shadowRoot;
        if (!this.isStore) {
            console.log('jeep-sqlite isStore = false');
        }
    }
    //******************************
    //* Private Method Definitions *
    //******************************
    async _createConnection(database, version, readonly) {
        let upgDict = {};
        const vUpgKeys = Object.keys(this._versionUpgrades);
        if (vUpgKeys.length !== 0 && vUpgKeys.includes(database)) {
            upgDict = this._versionUpgrades[database];
        }
        const dbDictKeys = Object.keys(this._dbDict);
        let mDB;
        try {
            if (dbDictKeys.length > 0 && (dbDictKeys.includes("RW_" + database) ||
                dbDictKeys.includes("RO_" + database))) {
                mDB = dbDictKeys.includes("RW_" + database) ? this._dbDict["RW_" + database]
                    : this._dbDict["RO_" + database];
            }
            else {
                mDB = new Database(database + 'SQLite.db', version, upgDict, this.store, this.innerAutoSave, this.innerWasmPath);
            }
            const connName = readonly ? "RO_" + database : "RW_" + database;
            this._dbDict[connName] = mDB;
            return Promise.resolve();
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(msg);
        }
    }
    async _isConnection(database, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = readonly ? "RO_" + database : "RW_" + database;
        if (keys.includes(connName)) {
            return { result: true };
        }
        else {
            return { result: false };
        }
    }
    async _closeConnection(database, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = readonly ? "RO_" + database : "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`CloseConnection: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        try {
            if (mDB.isDBOpen()) {
                await mDB.close();
            }
            // remove the connection from dictionary
            delete this._dbDict[connName];
            return Promise.resolve();
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`CloseConnection: ${msg}`);
        }
    }
    async _open(database, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = readonly ? "RO_" + database : "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`Open: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        try {
            await mDB.open();
            return Promise.resolve();
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`Open: ${msg}`);
        }
    }
    async _close(database, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = readonly ? "RO_" + database : "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`Close: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`Close: ${database} database not opened`);
        }
        try {
            await mDB.close();
            return Promise.resolve();
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`Close: ${msg}`);
        }
    }
    async _saveToStore(database, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = readonly ? "RO_" + database : "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`SaveToStore: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`SaveToStore: ${database} database not opened`);
        }
        try {
            await mDB.saveToStore();
            return Promise.resolve();
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`SaveToStore: ${msg}`);
        }
    }
    async _saveToLocalDisk(database) {
        try {
            const keys = Object.keys(this._dbDict);
            const connName = "RW_" + database;
            if (!keys.includes(connName)) {
                return Promise.reject('SaveToLocalDisk: No available connection for ' + `${database}`);
            }
            const mDB = this._dbDict[connName];
            if (!mDB.isDBOpen()) {
                return Promise.reject(`SaveToLocalDisk: ${database} database not opened`);
            }
            const uint = await mDB.exportDB();
            this._blob = await this.uint2blob(uint);
            const dbName = `${database}SQLite.db`;
            this._opts = { fileName: dbName, extensions: ['.db'], startIn: 'documents', };
            this._buttonSaveEl = document.createElement('button');
            this._buttonSaveEl.setAttribute("id", "saveButton");
            this._buttonSaveEl.innerHTML = `${this.innerSaveText} ${dbName}`;
            this._element.appendChild(this._buttonSaveEl);
            this._buttonSaveEl.addEventListener("click", this.saveFile.bind(this));
            return Promise.resolve();
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`SaveToLocalDisk: ${msg}`);
        }
    }
    async _getFromLocalDiskToStore(overwrite) {
        this._buttonPickEl = document.createElement('button');
        this._buttonPickEl.setAttribute("id", "pickButton");
        this._buttonPickEl.innerHTML = `${this.innerPickText}`;
        this._element.appendChild(this._buttonPickEl);
        this._buttonPickEl.addEventListener("click", this.pickDatabase.bind(this));
        this._overwrite = overwrite;
        return Promise.resolve();
    }
    async pickDatabase() {
        try {
            const blob = await fileOpen({ extensions: ['.db'] });
            let uInt8Array = await this.blob2uint(blob);
            const databaseName = this.removePathSuffix(blob.name);
            const dbName = this.setPathSuffix(blob.name);
            // check if dbName exists
            const isExist = await UtilsStore.isDBInStore(dbName, this.store);
            if (!isExist) {
                await UtilsStore.saveDBToStore(dbName, uInt8Array, this.store);
            }
            else {
                if (this._overwrite) {
                    await UtilsStore.removeDBFromStore(dbName, this.store);
                    await UtilsStore.saveDBToStore(dbName, uInt8Array, this.store);
                }
                else {
                    this.PickDatabaseEnded.emit({ message: `Error: cannot overwrite ${dbName}` });
                }
            }
            this._element.removeChild(this._buttonPickEl);
            this.PickDatabaseEnded.emit({ db_name: databaseName });
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            this.PickDatabaseEnded.emit({ message: msg });
        }
    }
    async saveFile() {
        try {
            await fileSave(this._blob, [this._opts]);
            const databaseName = this._opts.fileName;
            this._element.removeChild(this._buttonSaveEl);
            this.SaveDatabaseEnded.emit({ db_name: databaseName });
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            this.SaveDatabaseEnded.emit({ message: msg });
        }
    }
    async _getVersion(database, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = readonly ? "RO_" + database : "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`Open: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`GetVersion: ${database} database not opened`);
        }
        try {
            const version = await mDB.getVersion();
            const ret = {};
            ret.version = version;
            return Promise.resolve(ret);
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`Open: ${msg}`);
        }
    }
    async _beginTransaction(database) {
        const keys = Object.keys(this._dbDict);
        const connName = "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`BeginTransaction: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`BeginTransaction: ${database} database not opened`);
        }
        let changes = {};
        const ret = await mDB.beginTransaction();
        changes = { changes: { changes: ret } };
        return Promise.resolve(changes);
    }
    async _commitTransaction(database) {
        const keys = Object.keys(this._dbDict);
        const connName = "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`CommitTransaction: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`CommitTransaction: ${database} database not opened`);
        }
        let changes = {};
        const ret = await mDB.commitTransaction();
        changes = { changes: { changes: ret } };
        return Promise.resolve(changes);
    }
    async _rollbackTransaction(database) {
        const keys = Object.keys(this._dbDict);
        const connName = "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`RollbackTransaction: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`RollbackTransaction: ${database} database not opened`);
        }
        let changes = {};
        const ret = await mDB.rollbackTransaction();
        changes = { changes: { changes: ret } };
        return Promise.resolve(changes);
    }
    async _isTransactionActive(database) {
        const keys = Object.keys(this._dbDict);
        const connName = "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`IsTransactionActive: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`IsTransactionActive: ${database} database not opened`);
        }
        let result = {};
        const res = mDB.isTransActive();
        result = { result: res };
        return Promise.resolve(result);
    }
    async _execute(database, statements, transaction, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`Execute: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`Execute: ${database} database not opened`);
        }
        if (readonly) {
            return Promise.reject(`Execute: not allowed in read-only mode`);
        }
        let changes = {};
        const command = statements.substring(0, 6);
        if (this.innerAutoSave && command === "COMMIT" && this.innerTypeOrm) {
            // fix issue for typeORM with autosave
            changes = { changes: { changes: 0 } };
            return Promise.resolve(changes);
        }
        try {
            const ret = await mDB.executeSQL(statements, transaction);
            changes = { changes: { changes: ret } };
            return Promise.resolve(changes);
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`Execute: ${msg}`);
        }
    }
    async _executeSet(database, setOfStatements, transaction, readonly, returnMode) {
        const keys = Object.keys(this._dbDict);
        const connName = "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`ExecuteSet: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`ExecuteSet: ${database} database not opened`);
        }
        if (readonly) {
            return Promise.reject(`ExecuteSet: not allowed in read-only mode`);
        }
        for (const sStmt of setOfStatements) {
            if (!('statement' in sStmt) || !('values' in sStmt)) {
                return Promise.reject('ExecuteSet: Must provide a set as ' + 'Array of {statement,values}');
            }
        }
        try {
            const ret = await mDB.execSet(setOfStatements, transaction, returnMode);
            const changes = { changes: { changes: ret.changes, lastId: ret.lastId,
                    values: ret.values } };
            return Promise.resolve(changes);
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`ExecuteSet: ${msg}`);
        }
    }
    async _run(database, statement, values, transaction, readonly, returnMode) {
        const keys = Object.keys(this._dbDict);
        const connName = "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`Run: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`Run: ${database} database not opened`);
        }
        if (readonly) {
            return Promise.reject(`Run: not allowed in read-only mode`);
        }
        let changes = {};
        const command = statement.substring(0, 6);
        if (this.innerAutoSave && command === "COMMIT") {
            // fix issue for typeORM with autosave
            changes = { changes: { changes: 0 } };
            return Promise.resolve(changes);
        }
        try {
            const ret = await mDB.runSQL(statement, values, transaction, returnMode);
            changes = { changes: { changes: ret.changes, lastId: ret.lastId, values: ret.values } };
            return Promise.resolve(changes);
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`Run: ${msg}`);
        }
    }
    async _query(database, statement, values, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = readonly ? "RO_" + database : "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`Query: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`Query: ${database} database not opened`);
        }
        let ret = [];
        const command = statement.substring(0, 6);
        if (this.innerAutoSave && command === "COMMIT") {
            // fix issue for typeORM with autosave
            return Promise.resolve({ values: ret });
        }
        try {
            ret = await mDB.selectSQL(statement, values);
            return Promise.resolve({ values: ret });
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`Query failed: ${msg}`);
        }
    }
    async _getTableList(database, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = readonly ? "RO_" + database : "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`GetTableList: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`GetTableList: ${database} database not opened`);
        }
        let ret = [];
        try {
            ret = await mDB.getTableNames();
            return Promise.resolve({ values: ret });
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`GetTableList failed: ${msg}`);
        }
    }
    async _isDBExists(database, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = readonly ? "RO_" + database : "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`IsDBExists: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        /*    if (!mDB.isDBOpen()) {
              return Promise.reject(
                `IsDBExists: ${database} database not opened`);
            }
            */
        try {
            const ret = await mDB.isDBExists(database + 'SQLite.db');
            const result = { result: ret };
            return Promise.resolve(result);
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`IsDBExists: ${msg}`);
        }
    }
    async _isDBOpen(database, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = readonly ? "RO_" + database : "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`IsDBOpen: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            const result = { result: false };
            return Promise.resolve(result);
        }
        try {
            const ret = await mDB.isDBOpen(database + 'SQLite.db');
            const result = { result: ret };
            return Promise.resolve(result);
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`IsDBOpen: ${msg}`);
        }
    }
    async _deleteDatabase(database, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`DeleteDatabase: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (readonly) {
            return Promise.reject(`DeleteDatabase: not allowed in read-only mode`);
        }
        try {
            await mDB.deleteDB(database + 'SQLite.db');
            return Promise.resolve();
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`DeleteDatabase: ${msg}`);
        }
    }
    async _isTableExists(database, table, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = readonly ? "RO_" + database : "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject(`IsTableExists: No available connection for ${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`IsTableExists: ${database} database not opened`);
        }
        try {
            const ret = await mDB.isTable(table);
            const result = { result: ret };
            return Promise.resolve(result);
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`IsTableExists: ${msg}`);
        }
    }
    async _createSyncTable(database, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject('CreateSyncTable: No available connection for ' + `${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`CreateSyncTable: ${database} database not opened`);
        }
        if (readonly) {
            return Promise.reject(`CreateSyncTable: not allowed in read-only mode`);
        }
        try {
            const ret = await mDB.createSyncTable();
            return Promise.resolve({ changes: { changes: ret } });
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`CreateSyncTable: ${msg}`);
        }
    }
    async _getSyncDate(database, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = readonly ? "RO_" + database : "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject('GetSyncDate: No available connection for ' + `${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`GetSyncDate: ${database} database not opened`);
        }
        try {
            const ret = await mDB.getSyncDate();
            return Promise.resolve({ syncDate: ret });
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`GetSyncDate: ${msg}`);
        }
    }
    async _setSyncDate(database, syncDate, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject('SetSyncDate: No available connection for ' + `${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`SetSyncDate: ${database} database not opened`);
        }
        if (readonly) {
            return Promise.reject(`SetSyncDate: not allowed in read-only mode`);
        }
        try {
            const ret = await mDB.setSyncDate(syncDate);
            if (ret.result) {
                return Promise.resolve();
            }
            else {
                return Promise.reject(`SetSyncDate: ${ret.message}`);
            }
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`SetSyncDate: ${msg}`);
        }
    }
    async _isJsonValid(jsonStrObj) {
        const jsonObj = JSON.parse(jsonStrObj);
        const isValid = await UtilsJSON.isJsonSQLite(jsonObj);
        if (!isValid) {
            return Promise.reject('IsJsonValid: Stringify Json Object not Valid');
        }
        else {
            return Promise.resolve({ result: true });
        }
    }
    async _importFromJson(jsonStrObj) {
        var _a, _b;
        const jsonObj = JSON.parse(jsonStrObj);
        const isValid = await UtilsJSON.isJsonSQLite(jsonObj);
        if (!isValid) {
            return Promise.reject('ImportFromJson: Stringify Json Object not Valid');
        }
        const vJsonObj = jsonObj;
        const dbName = `${vJsonObj.database}SQLite.db`;
        const dbVersion = (_a = vJsonObj.version) !== null && _a !== void 0 ? _a : 1;
        const mode = vJsonObj.mode;
        const overwrite = (_b = vJsonObj.overwrite) !== null && _b !== void 0 ? _b : false;
        // Create the database
        const mDb = new Database(dbName, dbVersion, {}, this.store, this.innerAutoSave, this.innerWasmPath);
        try {
            if (overwrite && mode === 'full') {
                const isExists = UtilsStore.isDBInStore(dbName, this.store);
                if (isExists) {
                    await UtilsStore.removeDBFromStore(dbName, this.store);
                }
            }
            // Open the database
            await mDb.open();
            const tableList = await mDb.getTableNames();
            if (mode === 'full' && tableList.length > 0) {
                const curVersion = await mDb.getVersion();
                if (dbVersion < curVersion) {
                    return Promise.reject(`ImportFromJson: Cannot import a version lower than ${curVersion}`);
                }
                if (curVersion === dbVersion) {
                    return Promise.resolve({ changes: { changes: 0 } });
                }
            }
            // Import the JsonSQLite Object
            const changes = await mDb.importJson(vJsonObj, this.importProgress);
            // Close the database
            await mDb.close();
            return Promise.resolve({ changes: { changes: changes } });
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`ImportFromJson: ${msg}`);
        }
    }
    async _exportToJson(database, exportMode, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = readonly ? "RO_" + database : "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject('ExportToJson: No available connection for ' + `${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`ExportToJson: ${database} database not opened`);
        }
        try {
            const ret = await mDB.exportJson(exportMode, this.exportProgress);
            const keys = Object.keys(ret);
            if (keys.includes('message')) {
                return Promise.reject(`ExportToJson: ${ret.message}`);
            }
            else {
                return Promise.resolve({ export: ret });
            }
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`ExportToJson: ${msg}`);
        }
    }
    async _deleteExportedRows(database, readonly) {
        const keys = Object.keys(this._dbDict);
        const connName = "RW_" + database;
        if (!keys.includes(connName)) {
            return Promise.reject('DeleteExportedRows: No available connection for ' + `${database}`);
        }
        const mDB = this._dbDict[connName];
        if (!mDB.isDBOpen()) {
            return Promise.reject(`DeleteExportedRows: ${database} database not opened`);
        }
        if (readonly) {
            return Promise.reject(`DeleteExportedRows: not allowed in read-only mode`);
        }
        try {
            await mDB.deleteExportedRows();
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`DeleteExportedRows: ${msg}`);
        }
    }
    async _copyFromAssets(overwrite) {
        const res = await this.loadJSON('/assets/databases/databases.json');
        if (res != null) {
            this.databaseList = JSON.parse(res);
            const keys = Object.keys(this.databaseList);
            if (keys.includes("databaseList")) {
                try {
                    for (const dbName of this.databaseList.databaseList) {
                        if (dbName.substring(dbName.length - 3) === ".db") {
                            await this.copyDatabase(`/assets/databases/${dbName}`, overwrite);
                        }
                        if (dbName.substring(dbName.length - 4) === ".zip") {
                            await this.unzipDatabase(`/assets/databases/${dbName}`, overwrite);
                        }
                    }
                    return Promise.resolve();
                }
                catch (err) {
                    const msg = err.message ? err.message : err;
                    return Promise.reject(`CopyFromAssets: ${msg}`);
                }
            }
            else {
                return Promise.reject(`CopyFromAssets: no key databaseList in databases.json`);
            }
        }
        else {
            return Promise.reject(`CopyFromAssets: no databases.json file in /assets/databases folder`);
        }
    }
    async _getFromHTTPRequest(url, overwrite) {
        try {
            let message;
            if (url.substring(url.length - 3) === ".db") {
                await this.copyDatabase(url, overwrite);
                message = "db";
            }
            if (url.substring(url.length - 4) === ".zip") {
                await this.unzipDatabase(url, overwrite);
                message = "zip";
            }
            this.HTTPRequestEnded.emit({ message: message });
            return Promise.resolve();
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`GetFromHTTPRequest: ${msg}`);
        }
    }
    async _isDatabase(database) {
        try {
            const ret = await UtilsStore.isDBInStore(database + 'SQLite.db', this.store);
            const result = { result: ret };
            return Promise.resolve(result);
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`IsDatabase: ${msg}`);
        }
    }
    async _getDatabaseList() {
        try {
            const ret = await UtilsStore.getDBListFromStore(this.store);
            const result = { values: ret };
            return Promise.resolve(result);
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`GetDatabaseList: ${msg}`);
        }
    }
    async _checkConnectionsConsistency(dbNames, openModes) {
        const ret = {};
        ret.result = false;
        const dbConns = [];
        dbNames.forEach((value, i) => {
            dbConns.push(`${openModes[i]}_${value}`);
        });
        try {
            let inConnectionsSet = new Set(Object.keys(this._dbDict));
            const outConnectionSet = new Set(dbConns);
            if (outConnectionSet.size === 0) {
                await this._resetDbDict(Object.keys(this._dbDict));
                return Promise.resolve(ret);
            }
            if (inConnectionsSet.size < outConnectionSet.size) {
                await this._resetDbDict(Object.keys(this._dbDict));
                return Promise.resolve(ret);
            }
            if (inConnectionsSet.size > outConnectionSet.size) {
                const opt = {};
                for (const key of inConnectionsSet) {
                    if (!Array.from(outConnectionSet.keys()).includes(key)) {
                        let readonly = false;
                        if (key.substring(0, 3) === "RO_") {
                            readonly = true;
                        }
                        opt.database = key.substring(3);
                        opt.readonly = readonly;
                        await this._closeConnection(opt.database, opt.readonly);
                    }
                }
            }
            inConnectionsSet = new Set(Object.keys(this._dbDict));
            if (inConnectionsSet.size === outConnectionSet.size) {
                const symDiffSet = await this.symmetricDifference(inConnectionsSet, outConnectionSet);
                if (symDiffSet.size === 0) {
                    ret.result = true;
                    return Promise.resolve(ret);
                }
                else {
                    await this._resetDbDict(Object.keys(this._dbDict));
                    return Promise.resolve(ret);
                }
            }
            else {
                await this._resetDbDict(Object.keys(this._dbDict));
                return Promise.resolve(ret);
            }
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`CheckConnectionsConsistency: ${msg}`);
        }
    }
    async _resetDbDict(keys) {
        try {
            for (const key of keys) {
                const opt = {};
                let readonly = false;
                if (key.substring(0, 3) === "RO_") {
                    readonly = true;
                }
                opt.database = key.substring(3);
                opt.readonly = readonly;
                await this._closeConnection(opt.database, opt.readonly);
            }
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`ResetDbDict: ${msg}`);
        }
    }
    async symmetricDifference(setA, setB) {
        let _difference = new Set();
        setA.forEach(element => {
            _difference.add(element.substring(3));
        });
        let _compare = new Set();
        setB.forEach(element => {
            _compare.add(element.substring(3));
        });
        for (const elem of _compare) {
            if (_difference.has(elem)) {
                _difference.delete(elem);
            }
            else {
                _difference.add(elem);
            }
        }
        return _difference;
    }
    async unzipDatabase(dbZipName, overwrite) {
        return new Promise((resolve, reject) => {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', dbZipName, true);
            xhr.responseType = 'arraybuffer';
            xhr.onerror = () => {
                reject(new Error(`unzipDatabase: failed`));
            };
            xhr.onload = () => {
                JSZip.loadAsync(xhr.response).then(async (zip) => {
                    const keys = Object.keys(zip.files);
                    try {
                        // loop through file in the zip
                        for (const filename of keys) {
                            await this.retrieveDBFromZip(zip.files, filename, overwrite);
                        }
                        resolve();
                    }
                    catch (err) {
                        const msg = err.message ? err.message : err;
                        reject(new Error(`unzipDatabase Error: ${msg}`));
                    }
                });
            };
            xhr.send();
        });
    }
    async retrieveDBFromZip(zipFiles, fileName, overwrite) {
        return new Promise((resolve, reject) => {
            zipFiles[fileName].async('nodebuffer').then(async (fileData) => {
                try {
                    const uInt8Array = new Uint8Array(fileData);
                    const dbName = this.setPathSuffix(fileName);
                    // check if dbName exists
                    const isExist = await UtilsStore.isDBInStore(dbName, this.store);
                    if (!isExist) {
                        await UtilsStore.saveDBToStore(dbName, uInt8Array, this.store);
                    }
                    else {
                        if (overwrite) {
                            await UtilsStore.removeDBFromStore(dbName, this.store);
                            await UtilsStore.saveDBToStore(dbName, uInt8Array, this.store);
                        }
                        else {
                            reject(new Error(`retrieveDBFromZip: cannot overwrite ${dbName}`));
                        }
                    }
                    resolve();
                }
                catch (err) {
                    const msg = err.message ? err.message : err;
                    reject(new Error(`retrieveDBFromZip:: ${msg}`));
                }
            });
        });
    }
    async copyDatabase(dbInName, overwrite) {
        return new Promise((resolve, reject) => {
            var xhr = new XMLHttpRequest();
            var uInt8Array;
            xhr.open('GET', dbInName, true);
            xhr.responseType = 'arraybuffer';
            xhr.onerror = () => {
                reject(new Error(`CopyDatabase: failed`));
            };
            xhr.onload = () => {
                uInt8Array = new Uint8Array(xhr.response);
            };
            xhr.onloadend = async () => {
                const dbName = this.setPathSuffix(dbInName);
                // check if dbName exists
                const isExist = await UtilsStore.isDBInStore(dbName, this.store);
                if (!isExist) {
                    await UtilsStore.saveDBToStore(dbName, uInt8Array, this.store);
                }
                else {
                    if (overwrite) {
                        await UtilsStore.removeDBFromStore(dbName, this.store);
                        await UtilsStore.saveDBToStore(dbName, uInt8Array, this.store);
                    }
                    else {
                        reject(new Error(`CopyDatabase Error: cannot overwrite ${dbName}`));
                    }
                }
                resolve();
            };
            xhr.send();
        });
    }
    async loadJSON(jsonFileName) {
        return new Promise((resolve, reject) => {
            var xobj = new XMLHttpRequest();
            xobj.overrideMimeType("application/json");
            xobj.open('GET', jsonFileName, true);
            xobj.onerror = () => {
                reject(new Error(`LoadJSON: failed`));
            };
            xobj.onreadystatechange = function () {
                if (xobj.status == 404)
                    resolve(null);
                if (xobj.readyState == 4 && xobj.status == 200) {
                    // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
                    resolve(xobj.responseText);
                }
            };
            xobj.send(null);
        });
    }
    async openStore(dbName, tableName) {
        let ret = false;
        const config = this.setConfig(dbName, tableName);
        this.store = localForage.createInstance(config);
        if (this.store != null) {
            this.storeName = dbName;
            ret = true;
        }
        return ret;
    }
    setConfig(dbName, tableName) {
        const config = {
            name: dbName,
            storeName: tableName,
            driver: [localForage.INDEXEDDB],
            version: 1,
        };
        return config;
    }
    removePathSuffix(db) {
        return db.includes("SQLite.db") ?
            db.split("SQLite.db")[0] :
            db.substring(db.length - 3) === ".db" ?
                db.slice(0, db.lastIndexOf(".")) :
                db;
    }
    setPathSuffix(db) {
        let toDb = db.slice(db.lastIndexOf("/") + 1);
        const ext = ".db";
        if (db.substring(db.length - 3) === ext) {
            if (!db.includes("SQLite.db")) {
                toDb = db.slice(db.lastIndexOf("/") + 1, -3) + 'SQLite.db';
            }
        }
        return toDb;
    }
    async blob2uint(blob) {
        return new Response(blob).arrayBuffer().then(buffer => {
            const uint = new Uint8Array(buffer);
            return uint;
        });
    }
    async uint2blob(uint) {
        const blob = new Blob([uint.buffer]);
        return Promise.resolve(blob);
    }
    render() {
        return;
    }
    static get is() { return "jeep-sqlite"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["jeep-sqlite.css"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["jeep-sqlite.css"]
        };
    }
    static get assetsDirs() { return ["assets"]; }
    static get properties() {
        return {
            "autoSave": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "AutoSave"
                },
                "attribute": "autosave",
                "reflect": true,
                "defaultValue": "false"
            },
            "typeOrm": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "in use with TypeOrm"
                },
                "attribute": "typeorm",
                "reflect": true,
                "defaultValue": "false"
            },
            "wasmPath": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "WasmPath"
                },
                "attribute": "wasmpath",
                "reflect": true
            },
            "pickText": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Pick Button Text"
                },
                "attribute": "picktext",
                "reflect": true
            },
            "saveText": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Save Button Text"
                },
                "attribute": "savetext",
                "reflect": true
            },
            "buttonOptions": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Button Options"
                },
                "attribute": "buttonoptions",
                "reflect": true
            }
        };
    }
    static get states() {
        return {
            "innerAutoSave": {},
            "innerTypeOrm": {},
            "innerWasmPath": {},
            "innerPickText": {},
            "innerSaveText": {},
            "innerButtonOptions": {}
        };
    }
    static get events() {
        return [{
                "method": "importProgress",
                "name": "jeepSqliteImportProgress",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "complexType": {
                    "original": "JsonProgressListener",
                    "resolved": "JsonProgressListener",
                    "references": {
                        "JsonProgressListener": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::JsonProgressListener"
                        }
                    }
                }
            }, {
                "method": "exportProgress",
                "name": "jeepSqliteExportProgress",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "complexType": {
                    "original": "JsonProgressListener",
                    "resolved": "JsonProgressListener",
                    "references": {
                        "JsonProgressListener": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::JsonProgressListener"
                        }
                    }
                }
            }, {
                "method": "HTTPRequestEnded",
                "name": "jeepSqliteHTTPRequestEnded",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "complexType": {
                    "original": "HTTPRequestEndedListener",
                    "resolved": "HTTPRequestEndedListener",
                    "references": {
                        "HTTPRequestEndedListener": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::HTTPRequestEndedListener"
                        }
                    }
                }
            }, {
                "method": "PickDatabaseEnded",
                "name": "jeepSqlitePickDatabaseEnded",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "complexType": {
                    "original": "PickOrSaveDatabaseEndedListener",
                    "resolved": "PickOrSaveDatabaseEndedListener",
                    "references": {
                        "PickOrSaveDatabaseEndedListener": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::PickOrSaveDatabaseEndedListener"
                        }
                    }
                }
            }, {
                "method": "SaveDatabaseEnded",
                "name": "jeepSqliteSaveDatabaseToDisk",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "complexType": {
                    "original": "PickOrSaveDatabaseEndedListener",
                    "resolved": "PickOrSaveDatabaseEndedListener",
                    "references": {
                        "PickOrSaveDatabaseEndedListener": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::PickOrSaveDatabaseEndedListener"
                        }
                    }
                }
            }];
    }
    static get methods() {
        return {
            "echo": {
                "complexType": {
                    "signature": "(options: EchoOptions) => Promise<EchoResult>",
                    "parameters": [{
                            "name": "options",
                            "type": "EchoOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "EchoResult": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::EchoResult"
                        },
                        "EchoOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::EchoOptions"
                        }
                    },
                    "return": "Promise<EchoResult>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "createConnection": {
                "complexType": {
                    "signature": "(options: ConnectionOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "ConnectionOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "ConnectionOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::ConnectionOptions"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "isConnection": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<SQLiteResult>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteResult": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteResult"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<SQLiteResult>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "closeConnection": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "open": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "close": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "getVersion": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<SQLiteVersion>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteVersion": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteVersion"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<SQLiteVersion>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "beginTransaction": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<SQLiteChanges>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteChanges": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteChanges"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<SQLiteChanges>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "commitTransaction": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<SQLiteChanges>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteChanges": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteChanges"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<SQLiteChanges>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "rollbackTransaction": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<SQLiteChanges>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteChanges": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteChanges"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<SQLiteChanges>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "isTransactionActive": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<SQLiteResult>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteResult": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteResult"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<SQLiteResult>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "execute": {
                "complexType": {
                    "signature": "(options: SQLiteExecuteOptions) => Promise<SQLiteChanges>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteExecuteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteChanges": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteChanges"
                        },
                        "SQLiteExecuteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteExecuteOptions"
                        }
                    },
                    "return": "Promise<SQLiteChanges>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "executeSet": {
                "complexType": {
                    "signature": "(options: SQLiteSetOptions) => Promise<SQLiteChanges>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteSetOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteChanges": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteChanges"
                        },
                        "SQLiteSetOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteSetOptions"
                        },
                        "SQLiteSet": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteSet"
                        }
                    },
                    "return": "Promise<SQLiteChanges>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "run": {
                "complexType": {
                    "signature": "(options: SQLiteRunOptions) => Promise<SQLiteChanges>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteRunOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteChanges": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteChanges"
                        },
                        "SQLiteRunOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteRunOptions"
                        }
                    },
                    "return": "Promise<SQLiteChanges>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "query": {
                "complexType": {
                    "signature": "(options: SQLiteQueryOptions) => Promise<SQLiteValues>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteQueryOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteValues": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteValues"
                        },
                        "SQLiteQueryOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteQueryOptions"
                        }
                    },
                    "return": "Promise<SQLiteValues>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "getTableList": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<SQLiteValues>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteValues": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteValues"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<SQLiteValues>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "isDBExists": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<SQLiteResult>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteResult": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteResult"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<SQLiteResult>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "isDBOpen": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<SQLiteResult>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteResult": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteResult"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<SQLiteResult>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "deleteDatabase": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "isStoreOpen": {
                "complexType": {
                    "signature": "() => Promise<boolean>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<boolean>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "copyFromAssets": {
                "complexType": {
                    "signature": "(options: SQLiteFromAssetsOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteFromAssetsOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteFromAssetsOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteFromAssetsOptions"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "isTableExists": {
                "complexType": {
                    "signature": "(options: SQLiteTableOptions) => Promise<SQLiteResult>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteTableOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteResult": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteResult"
                        },
                        "SQLiteTableOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteTableOptions"
                        }
                    },
                    "return": "Promise<SQLiteResult>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "createSyncTable": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<SQLiteChanges>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteChanges": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteChanges"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<SQLiteChanges>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "getSyncDate": {
                "complexType": {
                    "signature": "(options: SQLiteSyncDateOptions) => Promise<SQLiteSyncDate>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteSyncDateOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteSyncDate": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteSyncDate"
                        },
                        "SQLiteSyncDateOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteSyncDateOptions"
                        }
                    },
                    "return": "Promise<SQLiteSyncDate>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "setSyncDate": {
                "complexType": {
                    "signature": "(options: SQLiteSyncDateOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteSyncDateOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteSyncDateOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteSyncDateOptions"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "isJsonValid": {
                "complexType": {
                    "signature": "(options: SQLiteImportOptions) => Promise<SQLiteResult>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteImportOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteResult": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteResult"
                        },
                        "SQLiteImportOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteImportOptions"
                        }
                    },
                    "return": "Promise<SQLiteResult>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "importFromJson": {
                "complexType": {
                    "signature": "(options: SQLiteImportOptions) => Promise<SQLiteChanges>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteImportOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteChanges": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteChanges"
                        },
                        "SQLiteImportOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteImportOptions"
                        }
                    },
                    "return": "Promise<SQLiteChanges>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "exportToJson": {
                "complexType": {
                    "signature": "(options: SQLiteExportOptions) => Promise<SQLiteJson>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteExportOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteJson": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteJson"
                        },
                        "SQLiteExportOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteExportOptions"
                        }
                    },
                    "return": "Promise<SQLiteJson>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "deleteExportedRows": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "addUpgradeStatement": {
                "complexType": {
                    "signature": "(options: SQLiteUpgradeOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteUpgradeOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteUpgradeOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteUpgradeOptions"
                        },
                        "SQLiteVersionUpgrade": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteVersionUpgrade"
                        },
                        "Record": {
                            "location": "global",
                            "id": "global::Record"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "isDatabase": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<SQLiteResult>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteResult": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteResult"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<SQLiteResult>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "getDatabaseList": {
                "complexType": {
                    "signature": "() => Promise<SQLiteValues>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteValues": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteValues"
                        }
                    },
                    "return": "Promise<SQLiteValues>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "checkConnectionsConsistency": {
                "complexType": {
                    "signature": "(options: AllConnectionsOptions) => Promise<SQLiteResult>",
                    "parameters": [{
                            "name": "options",
                            "type": "AllConnectionsOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteResult": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteResult"
                        },
                        "AllConnectionsOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::AllConnectionsOptions"
                        }
                    },
                    "return": "Promise<SQLiteResult>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "saveToStore": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "saveToLocalDisk": {
                "complexType": {
                    "signature": "(options: SQLiteOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteOptions"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "getFromLocalDiskToStore": {
                "complexType": {
                    "signature": "(options: SQLiteLocalDiskOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteLocalDiskOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteLocalDiskOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteLocalDiskOptions"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            },
            "getFromHTTPRequest": {
                "complexType": {
                    "signature": "(options: SQLiteHTTPOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "SQLiteHTTPOptions",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "SQLiteHTTPOptions": {
                            "location": "import",
                            "path": "../../interfaces/interfaces",
                            "id": "src/interfaces/interfaces.ts::SQLiteHTTPOptions"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "autoSave",
                "methodName": "parseAutoSave"
            }, {
                "propName": "typeOrm",
                "methodName": "parseTypeOrm"
            }, {
                "propName": "wasmPath",
                "methodName": "parseWasmPath"
            }, {
                "propName": "pickText",
                "methodName": "parsePickText"
            }, {
                "propName": "saveText",
                "methodName": "parseSaveText"
            }, {
                "propName": "buttonOptions",
                "methodName": "parseButtonOptions"
            }];
    }
}
//# sourceMappingURL=jeep-sqlite.js.map
