"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRootTsConfigFileName = exports.getRootTsConfigPath = exports.loadConfigFile = exports.dynamicImport = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const nx_1 = require("../../nx");
const { workspaceRoot, registerTsProject } = (0, nx_1.requireNx)();
exports.dynamicImport = new Function('modulePath', 'return import(modulePath);');
async function loadConfigFile(configFilePath) {
    {
        let module;
        if ((0, path_1.extname)(configFilePath) === '.ts') {
            const siblingFiles = (0, fs_1.readdirSync)((0, path_1.dirname)(configFilePath));
            const tsConfigPath = siblingFiles.includes('tsconfig.json')
                ? (0, path_1.join)((0, path_1.dirname)(configFilePath), 'tsconfig.json')
                : getRootTsConfigPath();
            if (tsConfigPath) {
                const unregisterTsProject = registerTsProject(tsConfigPath);
                try {
                    module = await load(configFilePath);
                }
                finally {
                    unregisterTsProject();
                }
            }
            else {
                module = await load(configFilePath);
            }
        }
        else {
            module = await load(configFilePath);
        }
        return module.default ?? module;
    }
}
exports.loadConfigFile = loadConfigFile;
function getRootTsConfigPath() {
    const tsConfigFileName = getRootTsConfigFileName();
    return tsConfigFileName ? (0, path_1.join)(workspaceRoot, tsConfigFileName) : null;
}
exports.getRootTsConfigPath = getRootTsConfigPath;
function getRootTsConfigFileName() {
    for (const tsConfigName of ['tsconfig.base.json', 'tsconfig.json']) {
        const pathExists = (0, fs_1.existsSync)((0, path_1.join)(workspaceRoot, tsConfigName));
        if (pathExists) {
            return tsConfigName;
        }
    }
    return null;
}
exports.getRootTsConfigFileName = getRootTsConfigFileName;
/**
 * Load the module after ensuring that the require cache is cleared.
 */
async function load(path) {
    // Clear cache if the path is in the cache
    if (require.cache[path]) {
        for (const k of Object.keys(require.cache)) {
            delete require.cache[k];
        }
    }
    try {
        // Try using `require` first, which works for CJS modules.
        // Modules are CJS unless it is named `.mjs` or `package.json` sets type to "module".
        return require(path);
    }
    catch (e) {
        if (e.code === 'ERR_REQUIRE_ESM') {
            // If `require` fails to load ESM, try dynamic `import()`.
            return await (0, exports.dynamicImport)(`${path}?t=${Date.now()}`);
        }
        // Re-throw all other errors
        throw e;
    }
}
